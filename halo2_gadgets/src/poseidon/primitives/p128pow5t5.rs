use halo2_proofs::arithmetic::Field;
use pasta_curves::{pallas::Base as Fp, vesta::Base as Fq};

use super::{Mds, Spec};

/// Poseidon-128 using the $x^5$ S-box, with a width of 5 field elements, and the
/// standard number of rounds for 128-bit security "with margin".
///
/// The standard specification for this set of parameters (on either of the Pasta
/// fields) uses $R_F = 8, R_P = 56$. This is conveniently an even number of
/// partial rounds, making it easier to construct a Halo 2 circuit.
#[derive(Debug)]
pub struct P128Pow5T5;

impl Spec<Fp, 5, 4> for P128Pow5T5 {
    fn full_rounds() -> usize {
        8
    }

    fn partial_rounds() -> usize {
        56
    }

    fn sbox(val: Fp) -> Fp {
        val.pow_vartime(&[5])
    }

    fn secure_mds() -> usize {
        unimplemented!()
    }

    fn constants() -> (Vec<[Fp; 5]>, Mds<Fp, 5>, Mds<Fp, 5>) {
        (
            super::fp::ROUND_CONSTANTS_T_5[..].to_vec(),
            super::fp::MDS_T_5,
            super::fp::MDS_INV_T_5,
        )
    }
}

impl Spec<Fq, 5, 4> for P128Pow5T5 {
    fn full_rounds() -> usize {
        8
    }

    fn partial_rounds() -> usize {
        56
    }

    fn sbox(val: Fq) -> Fq {
        val.pow_vartime(&[5])
    }

    fn secure_mds() -> usize {
        unimplemented!()
    }

    fn constants() -> (Vec<[Fq; 5]>, Mds<Fq, 5>, Mds<Fq, 5>) {
        (
            super::fq::ROUND_CONSTANTS_T_5[..].to_vec(),
            super::fq::MDS_T_5,
            super::fq::MDS_INV_T_5,
        )
    }
}

#[cfg(test)]
mod tests {
    use ff::PrimeField;
    use std::marker::PhantomData;

    use pasta_curves::arithmetic::FieldExt;

    use super::{
        super::{fp, fq},
        Fp, Fq,
    };
    use crate::poseidon::primitives::{permute, ConstantLength, Hash, Spec};

    /// The same Poseidon specification as poseidon::P128Pow5T5, but constructed
    /// such that its constants will be generated at runtime.
    #[derive(Debug)]
    pub struct P128Pow5T5Gen<F: FieldExt, const SECURE_MDS: usize>(PhantomData<F>);

    impl<F: FieldExt, const SECURE_MDS: usize> P128Pow5T5Gen<F, SECURE_MDS> {
        pub fn new() -> Self {
            P128Pow5T5Gen(PhantomData::default())
        }
    }

    impl<F: FieldExt, const SECURE_MDS: usize> Spec<F, 5, 4> for P128Pow5T5Gen<F, SECURE_MDS> {
        fn full_rounds() -> usize {
            8
        }

        fn partial_rounds() -> usize {
            56
        }

        fn sbox(val: F) -> F {
            val.pow_vartime(&[5])
        }

        fn secure_mds() -> usize {
            SECURE_MDS
        }
    }

    #[test]
    fn verify_constants() {
        fn verify_constants_helper<F: FieldExt>(
            expected_round_constants: [[F; 5]; 64],
            expected_mds: [[F; 5]; 5],
            expected_mds_inv: [[F; 5]; 5],
        ) {
            let (round_constants, mds, mds_inv) = P128Pow5T5Gen::<F, 0>::constants();

            for (actual, expected) in round_constants
                .iter()
                .flatten()
                .zip(expected_round_constants.iter().flatten())
            {
                assert_eq!(actual, expected);
            }

            for (actual, expected) in mds.iter().flatten().zip(expected_mds.iter().flatten()) {
                assert_eq!(actual, expected);
            }

            for (actual, expected) in mds_inv
                .iter()
                .flatten()
                .zip(expected_mds_inv.iter().flatten())
            {
                assert_eq!(actual, expected);
            }
        }

        verify_constants_helper(fp::ROUND_CONSTANTS_T_5, fp::MDS_T_5, fp::MDS_INV_T_5);
        verify_constants_helper(fq::ROUND_CONSTANTS_T_5, fq::MDS_T_5, fq::MDS_INV_T_5);
    }

    #[test]
    fn test_against_reference() {
        {
            // <https://github.com/daira/pasta-hadeshash>, using parameters from
            // `generate_parameters_grain.sage 1 0 255 3 8 56 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001`.
            // The test vector is generated by `sage poseidonperm_x5_pallas_3.sage --rust`

            let mut input = [
                Fp::from_raw([
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                ]),
                Fp::from_raw([
                    0x0000_0000_0000_0001,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                ]),
                Fp::from_raw([
                    0x0000_0000_0000_0002,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                ]),
                Fp::from_raw([
                    0x0000_0000_0000_0003,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                ]),
                Fp::from_raw([
                    0x0000_0000_0000_0004,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                ]),
            ];

            let expected_output = [
                Fp::from_raw([
                    0xecbd_a26c_cfff_48e5,
                    0x0ffa_ea83_d0a7_94ed,
                    0x5363_aca8_b22d_1b69,
                    0x0781_eb37_2f9a_0e75,
                ]),
                Fp::from_raw([
                    0x6328_dbd1_d9ba_6828,
                    0x1adb_a290_095c_b5ce,
                    0x0f61_943e_57b0_3fd0,
                    0x3abb_5624_f2b0_3e72,
                ]),
                Fp::from_raw([
                    0x90b7_bd69_caed_12fc,
                    0x9035_cca8_b934_ed63,
                    0xa733_f6f1_1f85_d30e,
                    0x24de_dc33_a743_9199,
                ]),
                Fp::from_raw([
                    0x1a0f_7644_bce3_3cc0,
                    0x645a_80c6_0586_ab86,
                    0x76e3_c50a_3481_4055,
                    0x02fd_4fff_6186_8c9f,
                ]),
                Fp::from_raw([
                    0xb79d_4775_c6ca_ce72,
                    0x129d_4ea6_68e8_e75b,
                    0xa351_8ad3_ab03_cb2d,
                    0x2d0d_0e1f_b0c6_c5a2,
                ]),
            ];

            permute::<Fp, P128Pow5T5Gen<Fp, 0>, 5, 4>(&mut input, &fp::MDS_T_5, &fp::ROUND_CONSTANTS_T_5);
            assert_eq!(input, expected_output);
        }

        {
            // <https://github.com/daira/pasta-hadeshash>, using parameters from
            // `generate_parameters_grain.sage 1 0 255 3 8 56 0x40000000000000000000000000000000224698fc0994a8dd8c46eb2100000001`.
            // The test vector is generated by `sage poseidonperm_x5_vesta_3.sage --rust`

            let mut input = [
                Fq::from_raw([
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                ]),
                Fq::from_raw([
                    0x0000_0000_0000_0001,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                ]),
                Fq::from_raw([
                    0x0000_0000_0000_0002,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                ]),
                Fq::from_raw([
                    0x0000_0000_0000_0003,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                ]),
                Fq::from_raw([
                    0x0000_0000_0000_0004,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                    0x0000_0000_0000_0000,
                ]),        
            ];

            let expected_output = [
                Fq::from_raw([
                    0x7ad4_f4bc_416f_d85a,
                    0xa4de_ff5a_0b6d_6b4a,
                    0xf11c_ee42_f966_ae99,
                    0x39c7_7567_216d_4e7e,
                ]),
                Fq::from_raw([
                    0xc7ac_000a_b0b9_04fb,
                    0x5dab_9d84_c74d_d7d5,
                    0xebc5_b3ca_076b_84c8,
                    0x202d_eaa1_8d2b_fb69,
                ]),
                Fq::from_raw([
                    0x2e85_091f_2234_d464,
                    0xdb66_a5f1_565f_01b0,
                    0xff01_9577_a7ed_c661,
                    0x1dbf_c28b_fe6d_9204,
                ]),
                Fq::from_raw([
                    0x9ee5_7182_536b_508e,
                    0xce20_7db0_a203_2ee4,
                    0xac9b_e705_0f51_6b7b,
                    0x2961_587d_ff96_82f8,
                ]),
                Fq::from_raw([
                    0x73fb_c034_bcbf_cd30,
                    0x6477_116b_d70e_67b6,
                    0xecf5_1cde_9716_f0e1,
                    0x3ea7_0c43_cd97_3227,
                ]),
            ];

            permute::<Fq, P128Pow5T5Gen<Fq, 0>, 5, 4>(&mut input, &fq::MDS_T_5, &fq::ROUND_CONSTANTS_T_5);
            assert_eq!(input, expected_output);
        }
    }

    //
    //
    // These test vectors are not available.
    // the link (https://github.com/zcash-hackworks/zcash-test-vectors/blob/master/orchard_poseidon/permute/fp.py) in `test_vectors.rs` line 19 does not work.
    //
    //

    // #[test]
    // fn permute_test_vectors() {
    //     {
    //         let (round_constants, mds, _) = super::P128Pow5T5::constants();

    //         for tv in crate::poseidon::primitives::test_vectors::fp::permute() {
    //             let mut state = [
    //                 Fp::from_repr(tv.initial_state[0]).unwrap(),
    //                 Fp::from_repr(tv.initial_state[1]).unwrap(),
    //                 Fp::from_repr(tv.initial_state[2]).unwrap(),
    //             ];

    //             permute::<Fp, super::P128Pow5T5, 5, 4>(&mut state, &mds, &round_constants);

    //             for (expected, actual) in tv.final_state.iter().zip(state.iter()) {
    //                 assert_eq!(&actual.to_repr(), expected);
    //             }
    //         }
    //     }

    //     {
    //         let (round_constants, mds, _) = super::P128Pow5T5::constants();

    //         for tv in crate::poseidon::primitives::test_vectors::fq::permute() {
    //             let mut state = [
    //                 Fq::from_repr(tv.initial_state[0]).unwrap(),
    //                 Fq::from_repr(tv.initial_state[1]).unwrap(),
    //                 Fq::from_repr(tv.initial_state[2]).unwrap(),
    //             ];

    //             permute::<Fq, super::P128Pow5T5, 5, 4>(&mut state, &mds, &round_constants);

    //             for (expected, actual) in tv.final_state.iter().zip(state.iter()) {
    //                 assert_eq!(&actual.to_repr(), expected);
    //             }
    //         }
    //     }
    // }

    // #[test]
    // fn hash_test_vectors() {
    //     for tv in crate::poseidon::primitives::test_vectors::fp::hash() {
    //         let message = [
    //             Fp::from_repr(tv.input[0]).unwrap(),
    //             Fp::from_repr(tv.input[1]).unwrap(),
    //         ];

    //         let result =
    //             Hash::<_, super::P128Pow5T5, ConstantLength<2>, 5, 4>::init().hash(message);

    //         assert_eq!(result.to_repr(), tv.output);
    //     }

    //     for tv in crate::poseidon::primitives::test_vectors::fq::hash() {
    //         let message = [
    //             Fq::from_repr(tv.input[0]).unwrap(),
    //             Fq::from_repr(tv.input[1]).unwrap(),
    //         ];

    //         let result =
    //             Hash::<_, super::P128Pow5T5, ConstantLength<2>, 5, 4>::init().hash(message);

    //         assert_eq!(result.to_repr(), tv.output);
    //     }
    // }
}
